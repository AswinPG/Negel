using Negel.Models;
using Negel.Subject;
using Plugin.CloudFirestore;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;
using TomQuiz.API;
using Xamarin.Forms;

namespace Negel
{
    // Learn more about making custom code visible in the Xamarin.Forms previewer
    // by visiting https://aka.ms/xamarinforms-previewer
    [DesignTimeVisible(false)]
    public partial class MainPage : ContentPage
    {
        public MainPage()
        {
            InitializeComponent();
            MainCollectionView.ItemsSource = new ObservableCollection<string>()
            {
                "SEPM",
                "PDD",
                "COA",
                "Maths",
                "OOP",
                "C#",
                "Java",
                "Python"


            };
        }

        private async void Button_Clicked(object sender, EventArgs e)
        {
            try
            {
                //string Json = "{\"Data\":[{\"Heading\":\"Defining Software\",\"Summary\":\"A textbook description of software might take the following form:   Software is: (1) instructions (computer programs) that when executed provide desired   features, function, and performance; (2) data structures that enable the programs to adequately manipulate information, and (3) descriptive information in both hard copy and   virtual forms that describes the operation and use of the programs. But a more formal definition probably won�t measurably improve your understanding. Software is developed or engineered; it is not manufactured in the classical sense. In both   activities, high quality is achieved through good design, but the manufacturing phase for hardware can introduce quality problems that are nonexistent          (or easily corrected) for software. Both activities are dependent on people,   but the relationship between people applied and work accomplished is   entirely different (see Chapter 24). Software doesn�t �wear out.�   Figure 1.1 depicts failure rate as a function of time for hardware. The relationship, often called the �bathtub curve,� indicates that hardware exhibits   relatively high failure rates early in its life (these failures are often attributable to design or manufacturing defects); defects are corrected and the failure   rate drops to a steady-state level (hopefully, quite low) for some period of   time. In theory, therefore, the failure rate curve for software   should take the form of the �idealized curve� shown in Figure 1.2. However, these are corrected and the curve flattens as shown. However, the implication is clear�software doesn�t wear out.        This seeming contradiction can best be explained by considering the   actual curve in Figure 1.2. During its life,2 software will undergo change. As   changes are made, it is likely that errors will be introduced, causing the   failure rate curve to spike as shown in the �actual curve� (Figure 1.2). Before   the curve can return to the original steady-state failure rate, another change   is requested, causing the curve to spike again. Slowly, the minimum failure   rate level begins to rise�the software is deteriorating due to change. Another aspect of wear illustrates the difference between hardware and   software. Every software failure indicates an   error in design or in the process through which design was translated into   machine executable code. Therefore, the software maintenance tasks that   accommodate requests for change involve considerably more complexity   than hardware maintenance. Although the industry is moving toward component-based construction, most   software continues to be custom built. As an engineering discipline evolves, a collection of standard design components is created. In the hardware world, component reuse is a natural part of   the engineering process. In the software world, it is something that has only   begun to be achieved on a broad scale. Modern reusable components encapsulate both data and the processing that is applied to the data, enabling the   software engineer to create new applications from reusable parts.3 For example, today�s interactive user interfaces are built with reusable components   that enable the creation of graphics windows, pull-down menus, and a wide   variety of interaction mechanisms. The data structures and processing detail   required to build the interface are contained within a library of reusable   components for interface construction.\"},{\"Heading\":\"Software Application Domains\",\"Summary\":\"In either case, the systems software area is characterized by heavy interaction   with computer hardware; heavy usage by multiple users; concurrent operation that requires scheduling, resource sharing, and sophisticated process   management; complex data structures; and multiple external interfaces. Application software�stand-alone programs that solve a specific business   need. Applications in this area process business or technical data in a way   that facilitates business operations or management/technical decision making. In addition to conventional data processing applications, application   software is used to control business functions in real time (e.g., point-of-sale   transaction processing, real-time manufacturing process control). Engineering/scientific software�has been characterized by �number   crunching� algorithms. Applications range from astronomy to volcanology,   from automotive stress analysis to space shuttle orbital dynamics, and   from molecular biology to automated manufacturing. Computer-aided design, system simulation, and other interactive applications have begun to take on real-time and   even system software characteristics. Embedded software�resides within a product or system and is used to   implement and control features and functions for the end user and for the   system itself. Embedded software can perform limited and esoteric functions   (e.g., key pad control for a microwave oven) or provide significant function   and control capability (e.g., digital functions in an automobile such as fuel   control, dashboard displays, and braking systems). Product-line software can focus on a limited and   esoteric marketplace (e.g., inventory control products) or address mass   consumer markets (e.g., word processing, spreadsheets, computer graphics,   multimedia, entertainment, database management, and personal and   business financial applications). In their simplest form, WebApps can   be little more than a set of linked hypertext files that present information   using text and limited graphics. Applications within this area include robotics, expert systems,   pattern recognition (image and voice), artificial neural networks, theorem   proving, and game playing. In some cases, new systems are being built, but in   many others, existing applications are being corrected, adapted, and enhanced. Hopefully, the legacy to be left behind by this generation will   ease the burden of future software engineers. And yet, new challenges (Chapter 31)   have appeared on the horizon:   Open-world computing�the rapid growth of wireless networking may   soon lead to true pervasive, distributed computing.        Netsourcing�the World Wide Web is rapidly becoming a computing engine   as well as a content provider. Open source�a growing trend that results in distribution of source code for   systems applications (e.g., operating systems, database, and development environments) so that many people can contribute to its development.\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Summary\":\"It follows that a concerted effort should be made to understand the   problem before a software solution is developed. � The information technology requirements demanded by individuals, businesses, and governments grow increasing complex with each passing year. Large teams of people now create computer programs that were once built   by a single individual. It   follows that design becomes a pivotal activity. If the software fails, people and major enterprises can experience   anything from minor inconvenience to catastrophic failures. It follows that   software should exhibit high quality. � As the perceived value of a specific application grows, the likelihood is that   its user base and longevity will also grow. As its user base and time-in-use          increase, demands for adaptation and enhancement will also grow. You will be tempted to add to this definition.9 It says little about the technical aspects of software quality; it does not directly address the need for customer satisfaction or timely product delivery; it omits mention of the importance of measurement   and metrics; it does not state the importance of an effective process. And yet, Bauer�s   definition provides us with a baseline. We need discipline, but we also need   adaptability and agility. Referring to Figure 1.3, any engineering approach (including software engineering) must rest on an organizational commitment to quality. The bedrock that supports software engineering is a quality focus. The foundation for software engineering is the process layer. Process defines a framework          that must be established for effective delivery of software engineering technology. The software process forms the basis for management control of software projects   and establishes the context in which technical methods are applied, work products   (models, documents, data, reports, forms, etc.) are produced, milestones are established, quality is ensured, and change is properly managed. Software engineering methods provide the technical how-to�s for building software. Methods encompass a broad array of tasks that include communication,   requirements analysis, design modeling, program construction, testing, and support. Software engineering tools provide automated or semiautomated support for the   process and the methods. When tools are integrated so that information created by   one tool can be used by another, a system for the support of software development,   called computer-aided software engineering, is established.\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Summary\":\"An activity strives to achieve a broad objective   (e.g., communication with stakeholders) and is applied regardless of the application   domain, size of the project, complexity of the effort, or degree of rigor with which   software engineering is to be applied. An action (e.g., architectural design) encompasses a set of tasks that produce a major work product (e.g., an architectural design   model). A task focuses on a small, but well-defined objective (e.g., conducting a unit   test) that produces a tangible outcome. In the context of software engineering, a process is not a rigid prescription for how   to build computer software. Rather, it is an adaptable approach that enables the people doing the work (the software team) to pick and choose the appropriate set of   work actions and tasks. The intent is always to deliver software in a timely manner   and with sufficient quality to satisfy those who have sponsored its creation and those   who will use it.        A process framework establishes the foundation for a complete software engineering process by identifying a small number of framework activities that are applicable to all software projects, regardless of their size or complexity. Any complicated journey can be simplified if a map exists. A   software project is a complicated journey, and the planning activity creates a   �map� that helps guide the team as it makes the journey. The map�called a   software project plan�defines the software engineering work by describing   the technical tasks to be conducted, the risks that are likely, the resources   that will be required, the work products to be produced, and a work   schedule. Whether you�re a landscaper, a bridge builder, an aeronautical   engineer, a carpenter, or an architect, you work with models every day. You   create a �sketch� of the thing so that you�ll understand the big picture�what   it will look like architecturally, how the constituent parts fit together, and   many other characteristics. If required, you refine the sketch into greater and   greater detail in an effort to better understand the problem and how you�re   going to solve it. This activity combines code generation (either manual or   automated) and the testing that is required to uncover errors in the code. The software (as a complete entity or as a partially completed increment) is delivered to the customer who evaluates the delivered   product and provides feedback based on the evaluation. That is, communication, planning, modeling, construction,   and deployment are applied repeatedly through a number of project iterations. In general, umbrella activities are applied throughout a software project and help a software team manage and control progress, quality,   change, and risk. Typical umbrella activities include:   Software project tracking and control�allows the software team to   assess progress against the project plan and take any necessary action to   maintain the schedule. Software quality assurance�defines and conducts the activities required   to ensure software quality. Therefore, a process adopted for one project might be significantly   different than a process adopted for another project. Among the differences are   � Overall flow of activities, actions, and tasks and the interdependencies   among them   � Degree to which actions and tasks are defined within each framework activity   � Degree to which work products are identified and required          � Manner in which quality assurance activities are applied   � Manner in which project tracking and control activities are applied   � Overall degree of detail and rigor with which the process is described   � Degree to which the customer and other stakeholders are involved with the   project   � Level of autonomy given to the software team   � Degree to which team organization and roles are prescribed   In Part 1 of this book, I�ll examine software process in considerable detail. Prescriptive   process models (Chapter 2) stress detailed definition, identification, and application   of process activities and tasks. Their intent is to improve system quality, make projects more manageable, make delivery dates and costs more predictable, and guide   teams of software engineers as they perform the work required to build a system. If   prescriptive models are applied dogmatically and without adaptation, they can increase the level of bureaucracy associated with building computer-based systems   and inadvertently create difficulty for all stakeholders. Agile process models (Chapter 3) emphasize project �agility� and follow a set of principles that lead to a more informal (but, proponents argue, no less effective) approach   to software process. These process models are generally characterized as �agile� because they emphasize maneuverability and adaptability.\"},{\"Heading\":\"A GENERIC PROCESS MODEL\",\"Summary\":\"In Chapter 1, a process was defined as a collection of work activities, actions, and   tasks that are performed when some work product is to be created. Each software engineering action is defined by a task set that identifies the work   tasks that are to be completed, the work products that will be produced, the quality   assurance points that will be required, and the milestones that will be used to indicate progress. As I discussed in Chapter 1, a generic process framework for software engineering defines five framework activities�communication, planning, modeling,   construction, and deployment. In addition, a set of umbrella activities�project   tracking and control, risk management, quality assurance, configuration management, technical reviews, and others�are applied throughout the process. This aspect�called process flow�describes how the framework activities and the actions and tasks that occur within each framework   activity are organized with respect to sequence and time and is illustrated in   Figure 2.2. A parallel process flow (Figure 2.2d) executes one or   more activities in parallel with other activities (e.g., modeling for one aspect of the   software might be executed in parallel with construction of another aspect of the   software).       \"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Summary\":\"Designing and building computer software is challenging, creative, and just plain   fun. In fact, building software is so compelling that many software developers want   to jump right in before they have a clear understanding of what is needed. They argue   that things will become clear as they build, that project stakeholders will be able to   understand need only after examining early iterations of the software, that things   change so rapidly that any attempt to understand requirements in detail is a waste   of time, that the bottom line is producing a working program and all else is secondary. From a software process perspective,   requirements engineering is a major software engineering action that begins during   the communication activity and continues into the modeling activity. Requirements engineering builds a bridge to design and construction. But where   does the bridge originate? Others might suggest that it begins with a broader   system definition, where software is but one component of the larger system   domain. But regardless of the starting point, the journey across the bridge takes you          high above the project, allowing you to examine the context of the software work to   be performed; the specific needs that design and construction must address; the priorities that guide the order in which work is to be completed; and the information,   functions, and behaviors that will have a profound impact on the resultant design. Requirements engineering provides the appropriate mechanism for understanding what the customer wants, analyzing need, assessing feasibility, negotiating a reasonable solution, specifying the solution unambiguously, validating the specification,   and managing the requirements as they are transformed into an operational system   [Tha97]. It encompasses seven distinct tasks: inception, elicitation, elaboration,   negotiation, specification, validation, and management. How does a software project get started? Is there a single event that   becomes the catalyst for a new computer-based system or product, or does the need   evolve over time? In some cases,   a casual conversation is all that is needed to precipitate a major software engineering effort. But in general, most projects begin when a business need is identified   or a potential new market or service is discovered. Stakeholders from the business   community (e.g., business managers, marketing people, product managers) define   a business case for the idea, try to identify the breadth and depth of the market, do a   rough feasibility analysis, and identify a working description of the project�s scope. All of this information is subject to change, but it is sufficient to precipitate discussions with the software engineering organization.2   At project inception,3 you establish a basic understanding of the problem, the people who want a solution, the nature of the solution that is desired, and the effectiveness of preliminary communication and collaboration between the other stakeholders   and the software team. It certainly seems simple enough�ask the customer, the users, and   others what the objectives for the system or product are, what is to be accomplished,   how the system or product fits into the needs of the business, and finally, how the system or product is to be used on a day-to-day basis. But it isn�t simple�it�s very hard. � Problems of scope. The boundary of the system is ill-defined or the   customers/users specify unnecessary technical detail that may confuse,   rather than clarify, overall system objectives. The customers/users are not completely sure   of what is needed, have a poor understanding of the capabilities and limitations of their computing environment, don�t have a full understanding of the   problem domain, have trouble communicating needs to the system engineer,   omit information that is believed to be �obvious,� specify requirements that   conflict with the needs of other customers/users, or specify requirements   that are ambiguous or untestable. � Problems of volatility. To help overcome these problems, you must approach requirements gathering in an   organized manner. The information obtained from the customer during inception and   elicitation is expanded and refined during elaboration. Elaboration is driven by the creation and refinement of user scenarios that describe how the end user (and other actors) will interact with the system. Each user   scenario is parsed to extract analysis classes�business domain entities that are   visible to the end user. The attributes of each analysis class are defined, and the services4 that are required by each class are identified. Using an iterative approach that prioritizes requirements, assesses   their cost and risk, and addresses internal conflicts, requirements are eliminated,   combined, and/or modified so that each party achieves some measure of satisfaction. A specification can be a written document, a set of graphical models, a formal mathematical model, a collection   of usage scenarios, a prototype, or any combination of these. The work products produced as a consequence of requirements engineering are assessed for quality during a validation step. Requirements for computer-based systems   change, and the desire to change requirements persists throughout the life of the   system. Requirements management is a set of activities that help the project team   identify, control, and track requirements and changes to requirements at any time as   the project proceeds.6 Many of these activities are identical to the software configuration management (SCM) techniques discussed in Chapter 22.          \"},{\"Heading\":\"SOFTWARE QUALITY\",\"Summary\":\"In the most general sense,   software quality can be defined1 as: An effective software process applied in a manner   that creates a useful product that provides measurable value for those who produce it   and those who use it. There is little question that the preceding definition could be modified or extended   and debated endlessly. The management aspects   of process create the checks and balances that help avoid project chaos�a   key contributor to poor quality. Software engineering practices allow the   developer to analyze the problem and design a solid solution�both critical   to building high-quality software. In addition, it satisfies a set of implicit   requirements (e.g., ease of use) that are expected of all high-quality software. By adding value for both the producer and user of a software product, highquality software provides benefits for the software organization and the enduser community. The software organization gains added value because   high-quality software requires less maintenance effort, fewer bug fixes, and   reduced customer support. This enables software engineers to spend more   time creating new applications and less on rework. The user community   gains added value because the application provides a useful capability in   a way that expedites some business process. The end result is (1) greater   software product revenue, (2) better profitability when an application   supports a business process, and/or (3) improved availability of information   that is crucial for the business.\"},{\"Heading\":\"THE ISO 9000 QUALITY STANDARDS\",\"Summary\":\"These systems cover a wide variety of activities encompassing a product�s entire life   cycle including planning, controlling, measuring, testing and reporting, and improving quality levels throughout the development and manufacturing process. Upon successful registration,   a company is issued a certificate from a registration body represented by the auditors. Semiannual surveillance audits ensure continued compliance to the standard.        The requirements delineated by ISO 9001:2000 address topics such as management responsibility, quality system, contract review, design control, document and   data control, product identification and traceability, process control, inspection and   testing, corrective and preventive action, control of quality records, internal quality   audits, training, servicing, and statistical techniques. If you desire   further information on ISO 9001:2000, see [Ant06], [Mut03], or [Dob04].\"},{\"Heading\":\"THE CMMI\",\"Summary\":\"Today, it has evolved into   the Capability Maturity Model Integration (CMMI) [CMM07], a comprehensive process   meta-model that is predicated on a set of system and software engineering capabilities that should be present as organizations reach different levels of process capability and maturity. The CMMI represents a process meta-model in two different ways: (1) as a   �continuous� model and (2) as a �staged� model. The continuous CMMI metamodel describes a process in two dimensions as illustrated in Figure 30.2. Each   process area (e.g., project planning or requirements management) is formally   assessed against specific goals and practices and is rated according to the following capability levels:   Level 0: Incomplete�the process area (e.g., requirements management) is   either not performed or does not achieve all goals and objectives defined by   the CMMI for level 1 capability for the process area. Work tasks required to produce defined   work products are being conducted. In addition, all work associated with the process area conforms to an organizationally   defined policy; all people doing the work have access to adequate resources   to get the job done; stakeholders are actively involved in the process area as   required; all work tasks and work products are �monitored, controlled, and   reviewed; and are evaluated for adherence to the process description� [CMM07]. In addition, the process is �tailored from the organization�s set of standard   processes according to the organization�s tailoring guidelines, and contributes work products, measures, and other process-improvement information to the organizational process assets� [CMM07]. In addition, the process area is controlled and improved using   measurement and quantitative assessment. �Quantitative objectives for quality and process performance are established and used as criteria in managing   the process� [CMM07]. In   addition, the process area is adapted and optimized using quantitative   (statistical) means to meet changing customer needs and to continually   improve the efficacy of the process area under consideration.        For example, project planning is one of eight process areas defined by the CMMI   for �project management� category.6 The specific goals (SG) and the associated specific practices (SP) defined for project planning are [CMM07]:   SG 1 Establish Estimates   SP 1.1-1 Estimate the Scope of the Project   SP 1.2-1 Establish Estimates of Work Product and Task Attributes   SP 1.3-1 Define Project Life Cycle   SP 1.4-1 Determine Estimates of Effort and Cost   SG 2 Develop a Project Plan   SP 2.1-1 Establish the Budget and Schedule   SP 2.2-1 Identify Project Risks   SP 2.3-1 Plan for Data Management   SP 2.4-1 Plan for Project Resources   SP 2.5-1 Plan for Needed Knowledge and Skills   SP 2.6-1 Plan Stakeholder Involvement   SP 2.7-1 Establish the Project Plan   SG 3 Obtain Commitment to the Plan   SP 3.1-1 Review Plans That Affect the Project   SP 3.2-1 Reconcile Work and Resource Levels   SP 3.3-1 Obtain Plan Commitment   In addition to specific goals and practices, the CMMI also defines a set of five   generic goals and related practices for each process area. Hence, to achieve a particular   capability level, the generic goal for that level and the generic practices that correspond to that goal must be achieved. The   relationship between maturity levels and process areas is shown in Figure 30.3.          30.4\"},{\"Heading\":\"WHITE-BOX TESTING\",\"Summary\":\"WHITE-BOX TESTING   White-box testing, sometimes called glass-box testing, is a test-case design philosophy that uses the control structure described as part of component-level design to   derive test cases.\"},{\"Heading\":\"THE RMMM PLAN\",\"Summary\":\"THE RMMM PLAN   A risk management strategy can be included in the software project plan, or the risk   management steps can be organized into a separate risk mitigation, monitoring, and   management plan (RMMM). The RMMM plan documents all work performed as part   of risk analysis and is used by the project manager as part of the overall project   plan. In most   cases, the RIS is maintained using a database system so that creation and information entry, priority ordering, searches, and other analysis may be accomplished easily. As I have already discussed, risk mitigation is a problem avoidance activity. Another job of   risk monitoring is to attempt to allocate origin [what risk(s) caused which problems   throughout the project].               28.8\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Summary\":\"They�ll need a few enhancements   to make it work in their world. The challenge of software maintenance has begun. You�re faced with a growing   queue of bug fixes, adaptation requests, and outright enhancements that must be          planned, scheduled, and ultimately accomplished. Before long, the queue has grown   long and the work it implies threatens to overwhelm the available resources. As time   passes, your organization finds that it�s spending more money and time maintaining   existing programs than it is engineering new applications. You may ask why so much maintenance is required and why so much effort is   expended. Even when   these programs were created using the best design and coding techniques known at the   time [and most were not], they were created when program size and storage space were   principle concerns. They were then migrated to new platforms, adjusted for changes in   machine and operating system technology and enhanced to meet new user needs�all   without enough regard to overall architecture. The result is the poorly designed structures, poor coding, poor logic, and poor documentation of the software systems we are   now called on to keep running . Another reason for the software maintenance problem is the mobility of software   people. Worse, other generations of software people have modified the   system and moved on. And today, there may be no one left who has any direct   knowledge of the legacy system. As I noted in Chapter 22, the ubiquitous nature of change underlies all software   work. Throughout this book, I�ve emphasized the importance of understanding the   problem (analysis) and developing a well-structured solution (design). In essence, maintainability is a qualitative indication1 of the ease with   which existing software can be corrected, adapted, or enhanced. It makes use of design patterns (Chapter 12) that allow ease of understanding. It has been constructed using well-defined coding standards and conventions, leading to source code that is self-documenting and understandable. Therefore, the design and implementation of the software must �assist� the person who is making the change.\"}]}";
                //TestData Data = Newtonsoft.Json.JsonConvert.DeserializeObject<TestData>(Json);
                string Json = "{\"Data\":[{\"Heading\":\"Defining Software\",\"Question\":\"________ is developed or engineered; it is not manufactured in the classical sense.\",\"Opt1\":\"return\",\"Opt2\":\"curve\",\"Opt3\":\"difference\",\"Opt4\":\"software\",\"Ans\":\"software\"},{\"Heading\":\"Defining Software\",\"Question\":\"In both   activities, high quality is achieved through good design, but the manufacturing phase for hardware can introduce quality problems that are nonexistent          (or easily corrected) for ________.\",\"Opt1\":\"period\",\"Opt2\":\"industry\",\"Opt3\":\"form\",\"Opt4\":\"software\",\"Ans\":\"software\"},{\"Heading\":\"Defining Software\",\"Question\":\"Both activities are dependent on people,   but the ________ between people applied and work accomplished is   entirely different (see Chapter 24).\",\"Opt1\":\"complexity\",\"Opt2\":\"menus\",\"Opt3\":\"example\",\"Opt4\":\"relationship\",\"Ans\":\"relationship\"},{\"Heading\":\"Defining Software\",\"Question\":\"Software doesn�t �wear out.�   Figure 1.1 depicts failure rate as a function of ________ for hardware.\",\"Opt1\":\"time\",\"Opt2\":\"creation\",\"Opt3\":\"menus\",\"Opt4\":\"library\",\"Ans\":\"time\"},{\"Heading\":\"Defining Software\",\"Question\":\"In theory, therefore, the failure rate curve for software   should ________ the form of the �idealized curve� shown in Figure 1.2.\",\"Opt1\":\"take\",\"Opt2\":\"wear\",\"Opt3\":\"performance\",\"Opt4\":\"spike\",\"Ans\":\"take\"},{\"Heading\":\"Defining Software\",\"Question\":\"During its ________,2 software will undergo change.\",\"Opt1\":\"wear\",\"Opt2\":\"life\",\"Opt3\":\"industry\",\"Opt4\":\"something\",\"Ans\":\"life\"},{\"Heading\":\"Defining Software\",\"Question\":\"As   changes are made, it is likely that errors will be introduced, causing the   failure rate curve to ________ as shown in the �actual curve� (Figure 1.2).\",\"Opt1\":\"spike\",\"Opt2\":\"industry\",\"Opt3\":\"period\",\"Opt4\":\"form\",\"Ans\":\"spike\"},{\"Heading\":\"Defining Software\",\"Question\":\"Before   the curve can ________ to the original steady-state failure rate, another change   is requested, causing the curve to spike again.\",\"Opt1\":\"design\",\"Opt2\":\"return\",\"Opt3\":\"example\",\"Opt4\":\"industry\",\"Ans\":\"return\"},{\"Heading\":\"Defining Software\",\"Question\":\"Slowly, the minimum failure   rate level begins to rise�the ________ is deteriorating due to change.\",\"Opt1\":\"software\",\"Opt2\":\"performance\",\"Opt3\":\"something\",\"Opt4\":\"collection\",\"Ans\":\"software\"},{\"Heading\":\"Defining Software\",\"Question\":\"Another aspect of wear illustrates the difference between hardware and   ________.\",\"Opt1\":\"menus\",\"Opt2\":\"form\",\"Opt3\":\"software\",\"Opt4\":\"software\",\"Ans\":\"software\"},{\"Heading\":\"Defining Software\",\"Question\":\"Every software failure indicates an   error in design or in the ________ through which design was translated into   machine executable code.\",\"Opt1\":\"curve\",\"Opt2\":\"industry\",\"Opt3\":\"process\",\"Opt4\":\"software\",\"Ans\":\"process\"},{\"Heading\":\"Defining Software\",\"Question\":\"Therefore, the software maintenance tasks that   accommodate requests for change involve considerably more ________   than hardware maintenance.\",\"Opt1\":\"example\",\"Opt2\":\"complexity\",\"Opt3\":\"life\",\"Opt4\":\"performance\",\"Ans\":\"complexity\"},{\"Heading\":\"Defining Software\",\"Question\":\"As an engineering discipline evolves, a ________ of standard design components is created.\",\"Opt1\":\"life\",\"Opt2\":\"curve\",\"Opt3\":\"dependent\",\"Opt4\":\"collection\",\"Ans\":\"collection\"},{\"Heading\":\"Defining Software\",\"Question\":\"In the software world, it is ________ that has only   begun to be achieved on a broad scale.\",\"Opt1\":\"period\",\"Opt2\":\"performance\",\"Opt3\":\"example\",\"Opt4\":\"something\",\"Ans\":\"something\"},{\"Heading\":\"Defining Software\",\"Question\":\"The data structures and processing detail   required to build the ________ are contained within a library of reusable   components for interface construction.\",\"Opt1\":\"interface\",\"Opt2\":\"wear\",\"Opt3\":\"implication\",\"Opt4\":\"form\",\"Ans\":\"interface\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"Application software�stand-alone programs that ________ a specific business   need.\",\"Opt1\":\"generation\",\"Opt2\":\"solve\",\"Opt3\":\"database\",\"Opt4\":\"development\",\"Ans\":\"solve\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"Applications in this area process business or technical data in a ________   that facilitates business operations or management/technical decision making.\",\"Opt1\":\"legacy\",\"Opt2\":\"development\",\"Opt3\":\"way\",\"Opt4\":\"system\",\"Ans\":\"way\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"In ________ to conventional data processing applications, application   software is used to control business functions in real time (e.g., point-of-sale   transaction processing, real-time manufacturing process control).\",\"Opt1\":\"addition\",\"Opt2\":\"computer\",\"Opt3\":\"engineering\",\"Opt4\":\"way\",\"Ans\":\"addition\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"Applications range from astronomy to ________,   from automotive stress analysis to space shuttle orbital dynamics, and   from molecular biology to automated manufacturing.\",\"Opt1\":\"engineering\",\"Opt2\":\"computer\",\"Opt3\":\"volcanology\",\"Opt4\":\"ease\",\"Ans\":\"volcanology\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"Embedded software�resides within a product or ________ and is used to   implement and control features and functions for the end user and for the   system itself.\",\"Opt1\":\"product\",\"Opt2\":\"system\",\"Opt3\":\"horizon\",\"Opt4\":\"distribution\",\"Ans\":\"system\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"Embedded software can perform limited and esoteric functions   (e.g., key pad control for a microwave oven) or provide significant function   and control capability (e.g., digital functions in an ________ such as fuel   control, dashboard displays, and braking systems).\",\"Opt1\":\"ease\",\"Opt2\":\"time\",\"Opt3\":\"engineering\",\"Opt4\":\"automobile\",\"Ans\":\"automobile\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"________-line software can focus on a limited and   esoteric marketplace (e.g., inventory control products) or address mass   consumer markets (e.g., word processing, spreadsheets, computer graphics,   multimedia, entertainment, database management, and personal and   business financial applications).\",\"Opt1\":\"astronomy\",\"Opt2\":\"product\",\"Opt3\":\"management\",\"Opt4\":\"volcanology\",\"Ans\":\"product\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"In their simplest form, ________ can   be little more than a set of linked hypertext files that present information   using text and limited graphics.\",\"Opt1\":\"volcanology\",\"Opt2\":\"astronomy\",\"Opt3\":\"webapps\",\"Opt4\":\"entertainment\",\"Ans\":\"webapps\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"Applications within this area include robotics, expert systems,   pattern recognition (________ and voice), artificial neural networks, theorem   proving, and game playing.\",\"Opt1\":\"generation\",\"Opt2\":\"entertainment\",\"Opt3\":\"image\",\"Opt4\":\"volcanology\",\"Ans\":\"image\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"In some ________, new systems are being built, but in   many others, existing applications are being corrected, adapted, and enhanced.\",\"Opt1\":\"database\",\"Opt2\":\"cases\",\"Opt3\":\"generation\",\"Opt4\":\"entertainment\",\"Ans\":\"cases\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"Hopefully, the ________ to be left behind by this generation will   ease the burden of future software engineers.\",\"Opt1\":\"way\",\"Opt2\":\"legacy\",\"Opt3\":\"system\",\"Opt4\":\"management\",\"Ans\":\"legacy\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"And yet, new challenges (Chapter 31)   have appeared on the ________:   Open-world computing�the rapid growth of wireless networking may   soon lead to true pervasive, distributed computing.\",\"Opt1\":\"horizon\",\"Opt2\":\"system\",\"Opt3\":\"entertainment\",\"Opt4\":\"database\",\"Ans\":\"horizon\"},{\"Heading\":\"Software Application Domains\",\"Question\":\"Open source�a growing trend that results in ________ of source code for   systems applications (e.g., operating systems, database, and development environments) so that many people can contribute to its development.\",\"Opt1\":\"addition\",\"Opt2\":\"distribution\",\"Opt3\":\"time\",\"Opt4\":\"management\",\"Ans\":\"distribution\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"It follows that a concerted effort should be made to ________ the   problem before a software solution is developed.\",\"Opt1\":\"context\",\"Opt2\":\"state\",\"Opt3\":\"importance\",\"Opt4\":\"understand\",\"Ans\":\"understand\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"� The information technology requirements demanded by ________, businesses, and governments grow increasing complex with each passing year.\",\"Opt1\":\"state\",\"Opt2\":\"measurement\",\"Opt3\":\"individuals\",\"Opt4\":\"understand\",\"Ans\":\"individuals\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"Large teams of ________ now create computer programs that were once built   by a single individual.\",\"Opt1\":\"state\",\"Opt2\":\"likelihood\",\"Opt3\":\"support\",\"Opt4\":\"people\",\"Ans\":\"people\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"If the software fails, ________ and major enterprises can experience   anything from minor inconvenience to catastrophic failures.\",\"Opt1\":\"people\",\"Opt2\":\"process\",\"Opt3\":\"framework\",\"Opt4\":\"change\",\"Ans\":\"people\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"It follows that   ________ should exhibit high quality.\",\"Opt1\":\"system\",\"Opt2\":\"software\",\"Opt3\":\"likelihood\",\"Opt4\":\"support\",\"Ans\":\"software\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"As its user base and ________-in-use          increase, demands for adaptation and enhancement will also grow.\",\"Opt1\":\"importance\",\"Opt2\":\"time\",\"Opt3\":\"enhancement\",\"Opt4\":\"context\",\"Ans\":\"time\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"And yet, Bauer�s   definition provides us with a ________.\",\"Opt1\":\"time\",\"Opt2\":\"measurement\",\"Opt3\":\"framework\",\"Opt4\":\"baseline\",\"Ans\":\"baseline\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"We need discipline, but we also need   adaptability and ________.\",\"Opt1\":\"framework\",\"Opt2\":\"agility\",\"Opt3\":\"quality\",\"Opt4\":\"understand\",\"Ans\":\"agility\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"Referring to Figure 1.3, any engineering approach (including software engineering) must rest on an organizational commitment to ________.\",\"Opt1\":\"likelihood\",\"Opt2\":\"adaptation\",\"Opt3\":\"quality\",\"Opt4\":\"enhancement\",\"Ans\":\"quality\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"The ________ that supports software engineering is a quality focus.\",\"Opt1\":\"state\",\"Opt2\":\"foundation\",\"Opt3\":\"bedrock\",\"Opt4\":\"baseline\",\"Ans\":\"bedrock\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"The software process forms the ________ for management control of software projects   and establishes the context in which technical methods are applied, work products   (models, documents, data, reports, forms, etc.)\",\"Opt1\":\"quality\",\"Opt2\":\"context\",\"Opt3\":\"likelihood\",\"Opt4\":\"basis\",\"Ans\":\"basis\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"are produced, milestones are established, ________ is ensured, and change is properly managed.\",\"Opt1\":\"importance\",\"Opt2\":\"quality\",\"Opt3\":\"process\",\"Opt4\":\"context\",\"Ans\":\"quality\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"Methods encompass a broad array of tasks that include communication,   requirements analysis, design modeling, program construction, testing, and ________.\",\"Opt1\":\"change\",\"Opt2\":\"context\",\"Opt3\":\"definition\",\"Opt4\":\"support\",\"Ans\":\"support\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"Software engineering tools provide automated or semiautomated support for the   ________ and the methods.\",\"Opt1\":\"time\",\"Opt2\":\"process\",\"Opt3\":\"change\",\"Opt4\":\"process\",\"Ans\":\"process\"},{\"Heading\":\"SOFTWARE ENGINEERING\",\"Question\":\"When tools are integrated so that information created by   one tool can be used by another, a ________ for the support of software development,   called computer-aided software engineering, is established.\",\"Opt1\":\"enhancement\",\"Opt2\":\"foundation\",\"Opt3\":\"system\",\"Opt4\":\"framework\",\"Ans\":\"system\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"An activity strives to achieve a broad objective   (e.g., communication with stakeholders) and is applied regardless of the application   domain, ________ of the project, complexity of the effort, or degree of rigor with which   software engineering is to be applied.\",\"Opt1\":\"size\",\"Opt2\":\"process\",\"Opt3\":\"carpenter\",\"Opt4\":\"effort\",\"Ans\":\"size\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"An ________ (e.g., architectural design) encompasses a set of tasks that produce a major work product (e.g., an architectural design   model).\",\"Opt1\":\"communication\",\"Opt2\":\"action\",\"Opt3\":\"thing\",\"Opt4\":\"help\",\"Ans\":\"action\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"A task focuses on a small, but well-defined objective (e.g., conducting a unit   test) that ________ a tangible outcome.\",\"Opt1\":\"risk\",\"Opt2\":\"construction\",\"Opt3\":\"produces\",\"Opt4\":\"system\",\"Ans\":\"produces\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"In the context of software engineering, a ________ is not a rigid prescription for how   to build computer software.\",\"Opt1\":\"process\",\"Opt2\":\"quality\",\"Opt3\":\"create\",\"Opt4\":\"system\",\"Ans\":\"process\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"The intent is always to deliver software in a timely manner   and with sufficient quality to satisfy those who have sponsored its creation and those   who will ________ it.\",\"Opt1\":\"identification\",\"Opt2\":\"code\",\"Opt3\":\"use\",\"Opt4\":\"perform\",\"Ans\":\"use\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"A process framework establishes the foundation for a complete software engineering process by identifying a small number of framework activities that are applicable to all software projects, regardless of their ________ or complexity.\",\"Opt1\":\"code\",\"Opt2\":\"size\",\"Opt3\":\"quality\",\"Opt4\":\"sketch\",\"Ans\":\"size\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"A   software project is a complicated journey, and the planning activity creates a   �map� that helps guide the ________ as it makes the journey.\",\"Opt1\":\"approach\",\"Opt2\":\"team\",\"Opt3\":\"problem\",\"Opt4\":\"construction\",\"Ans\":\"team\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"The map�called a   software project plan�defines the software engineering work by ________   the technical tasks to be conducted, the risks that are likely, the resources   that will be required, the work products to be produced, and a work   schedule.\",\"Opt1\":\"process\",\"Opt2\":\"describing\",\"Opt3\":\"customer\",\"Opt4\":\"risk\",\"Ans\":\"describing\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"Whether you�re a landscaper, a bridge builder, an aeronautical   engineer, a carpenter, or an architect, you ________ with models every day.\",\"Opt1\":\"project\",\"Opt2\":\"deployment\",\"Opt3\":\"level\",\"Opt4\":\"work\",\"Ans\":\"work\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"You   create a �sketch� of the ________ so that you�ll understand the big picture�what   it will look like architecturally, how the constituent parts fit together, and   many other characteristics.\",\"Opt1\":\"approach\",\"Opt2\":\"adaptability\",\"Opt3\":\"build\",\"Opt4\":\"thing\",\"Ans\":\"thing\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"This activity combines ________ generation (either manual or   automated) and the testing that is required to uncover errors in the code.\",\"Opt1\":\"thing\",\"Opt2\":\"level\",\"Opt3\":\"code\",\"Opt4\":\"creation\",\"Ans\":\"code\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"The ________ (as a complete entity or as a partially completed increment) is delivered to the customer who evaluates the delivered   product and provides feedback based on the evaluation.\",\"Opt1\":\"project\",\"Opt2\":\"software\",\"Opt3\":\"identification\",\"Opt4\":\"journey\",\"Ans\":\"software\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"That is, communication, planning, modeling, construction,   and deployment are applied repeatedly through a ________ of project iterations.\",\"Opt1\":\"approach\",\"Opt2\":\"foundation\",\"Opt3\":\"construction\",\"Opt4\":\"number\",\"Ans\":\"number\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"In general, umbrella activities are applied throughout a software project and help a software team manage and control progress, quality,   change, and ________.\",\"Opt1\":\"risk\",\"Opt2\":\"identification\",\"Opt3\":\"construction\",\"Opt4\":\"foundation\",\"Ans\":\"risk\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"Typical umbrella activities include:   Software project tracking and control�allows the software team to   assess progress against the project plan and take any necessary action to   maintain the ________.\",\"Opt1\":\"application\",\"Opt2\":\"schedule\",\"Opt3\":\"sketch\",\"Opt4\":\"complexity\",\"Ans\":\"schedule\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"Software quality assurance�defines and ________ the activities required   to ensure software quality.\",\"Opt1\":\"level\",\"Opt2\":\"number\",\"Opt3\":\"therefore\",\"Opt4\":\"conducts\",\"Ans\":\"conducts\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"Prescriptive   process models (Chapter 2) stress detailed definition, ________, and application   of process activities and tasks.\",\"Opt1\":\"construction\",\"Opt2\":\"code\",\"Opt3\":\"customer\",\"Opt4\":\"identification\",\"Ans\":\"identification\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"Their intent is to improve ________ quality, make projects more manageable, make delivery dates and costs more predictable, and guide   teams of software engineers as they perform the work required to build a system.\",\"Opt1\":\"team\",\"Opt2\":\"software\",\"Opt3\":\"system\",\"Opt4\":\"schedule\",\"Ans\":\"system\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"If   prescriptive models are applied dogmatically and without adaptation, they can ________ the level of bureaucracy associated with building computer-based systems   and inadvertently create difficulty for all stakeholders.\",\"Opt1\":\"work\",\"Opt2\":\"build\",\"Opt3\":\"increase\",\"Opt4\":\"create\",\"Ans\":\"increase\"},{\"Heading\":\"THE SOFTWARE PROCESS\",\"Question\":\"Agile process models (Chapter 3) emphasize project �agility� and follow a set of principles that lead to a more informal (but, proponents argue, no less effective) ________   to software process.\",\"Opt1\":\"adaptability\",\"Opt2\":\"approach\",\"Opt3\":\"book\",\"Opt4\":\"approach\",\"Ans\":\"approach\"},{\"Heading\":\"A GENERIC PROCESS MODEL\",\"Question\":\"A GENERIC ________ MODEL   In Chapter 1, a process was defined as a collection of work activities, actions, and   tasks that are performed when some work product is to be created.\",\"Opt1\":\"addition\",\"Opt2\":\"modeling\",\"Opt3\":\"process\",\"Opt4\":\"deployment\",\"Ans\":\"process\"},{\"Heading\":\"A GENERIC PROCESS MODEL\",\"Question\":\"As I discussed in Chapter 1, a generic process framework for software engineering defines five framework activities�communication, planning, modeling,   construction, and ________.\",\"Opt1\":\"deployment\",\"Opt2\":\"process\",\"Opt3\":\"planning\",\"Opt4\":\"deployment\",\"Ans\":\"deployment\"},{\"Heading\":\"A GENERIC PROCESS MODEL\",\"Question\":\"In addition, a set of umbrella activities�project   tracking and control, risk management, quality assurance, configuration management, technical reviews, and others�are applied throughout the ________.\",\"Opt1\":\"process\",\"Opt2\":\"addition\",\"Opt3\":\"control\",\"Opt4\":\"process\",\"Ans\":\"process\"},{\"Heading\":\"A GENERIC PROCESS MODEL\",\"Question\":\"This aspect�called process flow�describes how the framework activities and the actions and tasks that occur within each framework   activity are organized with respect to sequence and ________ and is illustrated in   Figure 2.2.\",\"Opt1\":\"planning\",\"Opt2\":\"construction\",\"Opt3\":\"time\",\"Opt4\":\"deployment\",\"Ans\":\"time\"},{\"Heading\":\"A GENERIC PROCESS MODEL\",\"Question\":\"A parallel process flow (Figure 2.2d) executes one or   more activities in parallel with other activities (e.g., modeling for one aspect of the   software might be executed in parallel with ________ of another aspect of the   software).\",\"Opt1\":\"modeling\",\"Opt2\":\"construction\",\"Opt3\":\"collection\",\"Opt4\":\"respect\",\"Ans\":\"construction\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"Designing and building computer software is ________, creative, and just plain   fun.\",\"Opt1\":\"collection\",\"Opt2\":\"class\",\"Opt3\":\"challenging\",\"Opt4\":\"work\",\"Ans\":\"challenging\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"In ________, building software is so compelling that many software developers want   to jump right in before they have a clear understanding of what is needed.\",\"Opt1\":\"life\",\"Opt2\":\"control\",\"Opt3\":\"fact\",\"Opt4\":\"nature\",\"Ans\":\"fact\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"From a software process perspective,   requirements engineering is a major software engineering action that ________ during   the communication activity and continues into the modeling activity.\",\"Opt1\":\"problem\",\"Opt2\":\"cost\",\"Opt3\":\"begins\",\"Opt4\":\"construction\",\"Ans\":\"begins\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"Requirements engineering builds a bridge to ________ and construction.\",\"Opt1\":\"clarify\",\"Opt2\":\"detail\",\"Opt3\":\"design\",\"Opt4\":\"solution\",\"Ans\":\"design\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"Others might suggest that it begins with a broader   system definition, where ________ is but one component of the larger system   domain.\",\"Opt1\":\"work\",\"Opt2\":\"software\",\"Opt3\":\"prototype\",\"Opt4\":\"scope\",\"Ans\":\"software\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"Requirements engineering provides the appropriate mechanism for understanding what the customer wants, analyzing need, assessing feasibility, negotiating a reasonable solution, specifying the solution unambiguously, validating the ________,   and managing the requirements as they are transformed into an operational system   [Tha97].\",\"Opt1\":\"describe\",\"Opt2\":\"specification\",\"Opt3\":\"cost\",\"Opt4\":\"time\",\"Ans\":\"specification\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"It encompasses seven distinct tasks: inception, elicitation, elaboration,   negotiation, specification, ________, and management.\",\"Opt1\":\"order\",\"Opt2\":\"consequence\",\"Opt3\":\"validation\",\"Opt4\":\"system\",\"Ans\":\"validation\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"Is there a single event that   becomes the catalyst for a new computer-based system or product, or does the need   evolve over ________?\",\"Opt1\":\"cost\",\"Opt2\":\"design\",\"Opt3\":\"time\",\"Opt4\":\"idea\",\"Ans\":\"time\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"In some cases,   a casual conversation is all that is needed to ________ a major software engineering effort.\",\"Opt1\":\"combination\",\"Opt2\":\"management\",\"Opt3\":\"information\",\"Opt4\":\"precipitate\",\"Ans\":\"precipitate\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"But in general, most projects begin when a business need is identified   or a potential new market or ________ is discovered.\",\"Opt1\":\"design\",\"Opt2\":\"service\",\"Opt3\":\"consequence\",\"Opt4\":\"specification\",\"Ans\":\"service\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"� Problems of ________.\",\"Opt1\":\"scope\",\"Opt2\":\"project\",\"Opt3\":\"life\",\"Opt4\":\"measure\",\"Ans\":\"scope\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"The boundary of the ________ is ill-defined or the   customers/users specify unnecessary technical detail that may confuse,   rather than clarify, overall system objectives.\",\"Opt1\":\"combination\",\"Opt2\":\"conflict\",\"Opt3\":\"work\",\"Opt4\":\"system\",\"Ans\":\"system\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"� Problems of ________.\",\"Opt1\":\"validation\",\"Opt2\":\"creation\",\"Opt3\":\"volatility\",\"Opt4\":\"clarify\",\"Ans\":\"volatility\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"To help overcome these ________, you must approach requirements gathering in an   organized manner.\",\"Opt1\":\"work\",\"Opt2\":\"elicitation\",\"Opt3\":\"problems\",\"Opt4\":\"measure\",\"Ans\":\"problems\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"Elaboration is driven by the creation and refinement of user scenarios that describe how the end user (and other actors) will interact with the ________.\",\"Opt1\":\"customer\",\"Opt2\":\"system\",\"Opt3\":\"consequence\",\"Opt4\":\"waste\",\"Ans\":\"system\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"The attributes of each analysis class are defined, and the ________ that are required by each class are identified.\",\"Opt1\":\"services4\",\"Opt2\":\"computer\",\"Opt3\":\"measure\",\"Opt4\":\"control\",\"Ans\":\"services4\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"Using an iterative approach that prioritizes requirements, assesses   their cost and risk, and addresses internal conflicts, requirements are eliminated,   combined, and/or modified so that each party achieves some measure of ________.\",\"Opt1\":\"satisfaction\",\"Opt2\":\"waste\",\"Opt3\":\"consequence\",\"Opt4\":\"combination\",\"Ans\":\"satisfaction\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"A ________ can be a written document, a set of graphical models, a formal mathematical model, a collection   of usage scenarios, a prototype, or any combination of these.\",\"Opt1\":\"problem\",\"Opt2\":\"prototype\",\"Opt3\":\"software\",\"Opt4\":\"specification\",\"Ans\":\"specification\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"The work products produced as a consequence of requirements engineering are assessed for ________ during a validation step.\",\"Opt1\":\"prototype\",\"Opt2\":\"desire\",\"Opt3\":\"system\",\"Opt4\":\"quality\",\"Ans\":\"quality\"},{\"Heading\":\"REQUIREMENTS ENGINEERING\",\"Question\":\"Requirements for computer-based ________s   change, and the desire to change requirements persists throughout the life of the   system.\",\"Opt1\":\"prototype\",\"Opt2\":\"system\",\"Opt3\":\"consequence\",\"Opt4\":\"inception\",\"Ans\":\"system\"},{\"Heading\":\"SOFTWARE QUALITY\",\"Question\":\"In the most general sense,   software quality can be defined1 as: An effective software process applied in a manner   that creates a ________ful product that provides measurable value for those who produce it   and those who use it.\",\"Opt1\":\"use\",\"Opt2\":\"manner\",\"Opt3\":\"developer\",\"Opt4\":\"addition\",\"Ans\":\"use\"},{\"Heading\":\"SOFTWARE QUALITY\",\"Question\":\"The management aspects   of process create the ________ and balances that help avoid project chaos�a   key contributor to poor quality.\",\"Opt1\":\"information\",\"Opt2\":\"produce\",\"Opt3\":\"problem\",\"Opt4\":\"checks\",\"Ans\":\"checks\"},{\"Heading\":\"SOFTWARE QUALITY\",\"Question\":\"Software engineering practices allow the   developer to analyze the ________ and design a solid solution�both critical   to building high-quality software.\",\"Opt1\":\"design\",\"Opt2\":\"way\",\"Opt3\":\"problem\",\"Opt4\":\"information\",\"Ans\":\"problem\"},{\"Heading\":\"SOFTWARE QUALITY\",\"Question\":\"In addition, it satisfies a set of implicit   requirements (e.g., ease of ________) that are expected of all high-quality software.\",\"Opt1\":\"producer\",\"Opt2\":\"user\",\"Opt3\":\"use\",\"Opt4\":\"manner\",\"Ans\":\"use\"},{\"Heading\":\"SOFTWARE QUALITY\",\"Question\":\"By adding value for both the producer and ________ of a software product, highquality software provides benefits for the software organization and the enduser community.\",\"Opt1\":\"user\",\"Opt2\":\"way\",\"Opt3\":\"addition\",\"Opt4\":\"business\",\"Ans\":\"user\"},{\"Heading\":\"SOFTWARE QUALITY\",\"Question\":\"This enables software engineers to spend more   time creating new applications and less on ________.\",\"Opt1\":\"information\",\"Opt2\":\"rework\",\"Opt3\":\"problem\",\"Opt4\":\"manner\",\"Ans\":\"rework\"},{\"Heading\":\"SOFTWARE QUALITY\",\"Question\":\"The user community   gains added value because the application provides a useful capability in   a ________ that expedites some business process.\",\"Opt1\":\"design\",\"Opt2\":\"user\",\"Opt3\":\"way\",\"Opt4\":\"information\",\"Ans\":\"way\"},{\"Heading\":\"SOFTWARE QUALITY\",\"Question\":\"The end result is (1) greater   software product revenue, (2) better profitability when an application   supports a business process, and/or (3) improved availability of ________   that is crucial for the business.\",\"Opt1\":\"producer\",\"Opt2\":\"problem\",\"Opt3\":\"produce\",\"Opt4\":\"information\",\"Ans\":\"information\"},{\"Heading\":\"THE ISO 9000 QUALITY STANDARDS\",\"Question\":\"These systems cover a wide variety of activities encompassing a product�s entire life   cycle including planning, controlling, measuring, testing and reporting, and improving quality levels throughout the ________ and manufacturing process.\",\"Opt1\":\"development\",\"Opt2\":\"control\",\"Opt3\":\"company\",\"Opt4\":\"document\",\"Ans\":\"development\"},{\"Heading\":\"THE ISO 9000 QUALITY STANDARDS\",\"Question\":\"Upon successful registration,   a ________ is issued a certificate from a registration body represented by the auditors.\",\"Opt1\":\"development\",\"Opt2\":\"company\",\"Opt3\":\"document\",\"Opt4\":\"company\",\"Ans\":\"company\"},{\"Heading\":\"THE ISO 9000 QUALITY STANDARDS\",\"Question\":\"Semiannual surveillance audits ensure continued compliance to the ________.\",\"Opt1\":\"document\",\"Opt2\":\"company\",\"Opt3\":\"standard\",\"Opt4\":\"see\",\"Ans\":\"standard\"},{\"Heading\":\"THE ISO 9000 QUALITY STANDARDS\",\"Question\":\"If you desire   further ________ on ISO 9001:2000, see [Ant06], [Mut03], or [Dob04].\",\"Opt1\":\"control\",\"Opt2\":\"development\",\"Opt3\":\"traceability\",\"Opt4\":\"information\",\"Ans\":\"information\"},{\"Heading\":\"THE CMMI\",\"Question\":\"The CMMI represents a process meta-________ in two different ways: (1) as a   �continuous� model and (2) as a �staged� model.\",\"Opt1\":\"example\",\"Opt2\":\"process\",\"Opt3\":\"model\",\"Opt4\":\"today\",\"Ans\":\"model\"},{\"Heading\":\"THE CMMI\",\"Question\":\"The continuous CMMI metamodel describes a ________ in two dimensions as illustrated in Figure 30.2.\",\"Opt1\":\"addition\",\"Opt2\":\"effort\",\"Opt3\":\"process\",\"Opt4\":\"hence\",\"Ans\":\"process\"},{\"Heading\":\"THE CMMI\",\"Question\":\"In addition, the process is �tailored from the organization�s ________ of standard   processes according to the organization�s tailoring guidelines, and contributes work products, measures, and other process-improvement information to the organizational process assets� [CMM07].\",\"Opt1\":\"set\",\"Opt2\":\"example\",\"Opt3\":\"relationship\",\"Opt4\":\"model\",\"Ans\":\"set\"},{\"Heading\":\"THE CMMI\",\"Question\":\"In ________, the process area is controlled and improved using   measurement and quantitative assessment.\",\"Opt1\":\"model\",\"Opt2\":\"system\",\"Opt3\":\"level\",\"Opt4\":\"addition\",\"Ans\":\"addition\"},{\"Heading\":\"THE CMMI\",\"Question\":\"�Quantitative objectives for ________ and process performance are established and used as criteria in managing   the process� [CMM07].\",\"Opt1\":\"affect\",\"Opt2\":\"quality\",\"Opt3\":\"today\",\"Opt4\":\"quality\",\"Ans\":\"quality\"},{\"Heading\":\"THE CMMI\",\"Question\":\"In   addition, the process area is adapted and optimized using quantitative   (statistical) means to meet changing customer needs and to continually   improve the efficacy of the process area under ________.\",\"Opt1\":\"effort\",\"Opt2\":\"quality\",\"Opt3\":\"affect\",\"Opt4\":\"consideration\",\"Ans\":\"consideration\"},{\"Heading\":\"THE CMMI\",\"Question\":\"The   ________ between maturity levels and process areas is shown in Figure 30.3.\",\"Opt1\":\"relationship\",\"Opt2\":\"example\",\"Opt3\":\"access\",\"Opt4\":\"adherence\",\"Ans\":\"relationship\"},{\"Heading\":\"WHITE-BOX TESTING\",\"Question\":\"White-box testing, sometimes called glass-box testing, is a test-case design philosophy that uses the control structure described as ________ of component-level design to   derive test cases.\",\"Opt1\":\"component\",\"Opt2\":\"part\",\"Opt3\":\"part\",\"Opt4\":\"software\",\"Ans\":\"part\"},{\"Heading\":\"THE RMMM PLAN\",\"Question\":\"In most   cases, the RIS is maintained using a database system so that ________ and information entry, priority ordering, searches, and other analysis may be accomplished easily.\",\"Opt1\":\"creation\",\"Opt2\":\"part\",\"Opt3\":\"monitoring\",\"Opt4\":\"creation\",\"Ans\":\"creation\"},{\"Heading\":\"THE RMMM PLAN\",\"Question\":\"Another job of   ________ monitoring is to attempt to allocate origin [what risk(s) caused which problems   throughout the project].\",\"Opt1\":\"risk\",\"Opt2\":\"part\",\"Opt3\":\"creation\",\"Opt4\":\"monitoring\",\"Ans\":\"risk\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"They�ll need a few enhancements   to make it work in their ________.\",\"Opt1\":\"today\",\"Opt2\":\"world\",\"Opt3\":\"time\",\"Opt4\":\"person\",\"Ans\":\"world\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"The ________ of software maintenance has begun.\",\"Opt1\":\"mobility\",\"Opt2\":\"maintainability\",\"Opt3\":\"challenge\",\"Opt4\":\"design\",\"Ans\":\"challenge\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"Before long, the queue has grown   long and the ________ it implies threatens to overwhelm the available resources.\",\"Opt1\":\"work\",\"Opt2\":\"today\",\"Opt3\":\"therefore\",\"Opt4\":\"book\",\"Ans\":\"work\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"As time   passes, your organization finds that it�s ________ more money and time maintaining   existing programs than it is engineering new applications.\",\"Opt1\":\"machine\",\"Opt2\":\"spending\",\"Opt3\":\"problem\",\"Opt4\":\"result\",\"Ans\":\"spending\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"Even when   these programs were created using the best design and coding techniques known at the   ________ [and most were not], they were created when program size and storage space were   principle concerns.\",\"Opt1\":\"time\",\"Opt2\":\"world\",\"Opt3\":\"person\",\"Opt4\":\"analysis\",\"Ans\":\"time\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"They were then migrated to new platforms, adjusted for changes in   ________ and operating system technology and enhanced to meet new user needs�all   without enough regard to overall architecture.\",\"Opt1\":\"machine\",\"Opt2\":\"design\",\"Opt3\":\"today\",\"Opt4\":\"challenge\",\"Ans\":\"machine\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"The ________ is the poorly designed structures, poor coding, poor logic, and poor documentation of the software systems we are   now called on to keep running .\",\"Opt1\":\"system\",\"Opt2\":\"ease\",\"Opt3\":\"result\",\"Opt4\":\"person\",\"Ans\":\"result\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"Another reason for the software maintenance problem is the ________ of software   people.\",\"Opt1\":\"need\",\"Opt2\":\"mobility\",\"Opt3\":\"result\",\"Opt4\":\"importance\",\"Ans\":\"mobility\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"Worse, other generations of software people have modified the   ________ and moved on.\",\"Opt1\":\"queue\",\"Opt2\":\"system\",\"Opt3\":\"importance\",\"Opt4\":\"overwhelm\",\"Ans\":\"system\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"And ________, there may be no one left who has any direct   knowledge of the legacy system.\",\"Opt1\":\"ease\",\"Opt2\":\"today\",\"Opt3\":\"work\",\"Opt4\":\"result\",\"Ans\":\"today\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"Throughout this book, I�ve emphasized the importance of understanding the   ________ (analysis) and developing a well-structured solution (design).\",\"Opt1\":\"problem\",\"Opt2\":\"result\",\"Opt3\":\"implementation\",\"Opt4\":\"work\",\"Ans\":\"problem\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"In essence, ________ is a qualitative indication1 of the ease with   which existing software can be corrected, adapted, or enhanced.\",\"Opt1\":\"maintainability\",\"Opt2\":\"today\",\"Opt3\":\"therefore\",\"Opt4\":\"implementation\",\"Ans\":\"maintainability\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"It has been constructed using well-defined coding standards and conventions, leading to source code that is ________-documenting and understandable.\",\"Opt1\":\"money\",\"Opt2\":\"need\",\"Opt3\":\"challenge\",\"Opt4\":\"self\",\"Ans\":\"self\"},{\"Heading\":\"SOFTWARE MAINTENANCE\",\"Question\":\"Therefore, the design and implementation of the software must �assist� the ________ who is making the change.\",\"Opt1\":\"person\",\"Opt2\":\"person\",\"Opt3\":\"challenge\",\"Opt4\":\"result\",\"Ans\":\"person\"}]}";
                Questions Data = Newtonsoft.Json.JsonConvert.DeserializeObject<Questions>(Json);

                //string Jsondata = reader.ReadToEnd();
                //string Jsondata = await responseMessage.Content.ReadAsStringAsync();
                //TestData testData = Newtonsoft.Json.JsonConvert.DeserializeObject<TestData>(Jsondata);



                //for (int i = 0; i < Data.Data.Count; i++)
                //{
                //    await CrossCloudFirestore.Current
                //                 .Instance
                //                 .GetCollection("Subjects")
                //                 .GetDocument("SEPM")
                //                 .GetCollection("Content")
                //                 .AddDocumentAsync(Data.Data[i]);
                //}



                //for (int i = 0; i < Data.Data.Count; i++)
                //{
                //    await CrossCloudFirestore.Current
                //                 .Instance
                //                 .GetCollection("Subjects")
                //                 .GetDocument("SEPM")
                //                 .GetCollection("Quiz")
                //                 .AddDocumentAsync(Data.Data[i]);
                //}
            }

            catch (Exception h)
            {

            }
            
        }

        private void ProfileTapped(object sender, EventArgs e)
        {

        }
        private void HomeTapped(object sender, EventArgs e)
        {

        }
        private void ChatTapped(object sender, EventArgs e)
        {

        }

        private void MainCollectionView_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if(MainCollectionView.SelectedItem != null)
            {
                Navigation.PushAsync(new SubjectDetailPage());
                MainCollectionView.SelectedItem = null;
            }
            else
            {

            }
        }
    }
    public class TestData
    {
        public ObservableCollection<Models.Content> Data { get; set; }
    }

    public class Questions
    {
        public List<Datum> Data { get; set; }
    }

    public class Datum
    {
        public string Heading { get; set; }

        public string Question { get; set; }

        public string Opt1 { get; set; }

        public string Opt2 { get; set; }

        public string Opt3 { get; set; }

        public string Opt4 { get; set; }

        public string Ans { get; set; }
    }
}
